ПЕРЕМЕННЫЕ:

        Переменная это как подписанная коробка с информацией.
        Название переменных не должн повторять зарезервированные слова в языке (error/promt/allert etc.)
        Название переменных не должно начинается с чисел или спец.символа (кроме $ и _)
        Название переменных должно быть понятным,правильным и осознанным
        let number переменная с именем 'number'
        let or const обьявление переменной
        let информация в переменной изменяема
        const информация в переменной постоянна
        Прямых констант в JS не бывает
        var устаревшее обьявление переменной,уже не используется
        = знак присваивания,этим знаком показываем что,что-то будет лежать в переменной
        ; ставим после обьявления переменной или когда закончился логический блок.

СИНТАКСИС:

    camel_Case 
        стандартный Синтаксис: начало с маленькой,остальное с большой и слитно
        Пример: const apiBase = "Lorem"

    snake_case
    UPPER_SNAKE_CASE  const COLOR_RED = "#F00";
        обычно так называют константы(например цвета)

    kebab-case 
        для папок и файлов,но не для переменных

    PascalCase 
        для названия классов в JS
        первая буква всегда с большой 

КЛАССИФИКАЦИЯ ТИПОВ ДАННЫХ В JS:
    Всего 8 типов данных:
    Типы данных могут переходить один в другой.

        Простые типы (примитивы) и комлексные типы (обьекты-делятся на специальные и обычные)
            Простые типы данных:
                1. Числа 1,2,3, нельзя задать числа,больше чем 2^53. let number = 4; Существует infinity (когда делим на 0) и NaN(not a number) когда не математическое выражение.
                2. Строки набор данных,которые можем описать словами,записуются в кавычках "string" "name".Могут содержать числа. const person = "Alex";
                3. Логический тип данных(boolean): либо True либо False. const bool = true;
                    Есть 5 сущностей,которые всегда будут False:
                        0; пустая строка ""; null; undefined; naN;
                4. null когда чего-то просто не сущестует. console.log(something);
                5. undefined что-то существует,но значения у него никакого нет(есть холодильник,но внутри пуст). 
                    let und;
                    console.log(und);
                6. Symbol новый тип данных. Почти не используется.
                7. BigInt новый тип данных,отображает большие числа

        Комплексные типы данных:
            Обьекты начинаются с {}. 
              Ключи в обьекте могут быть только строками или символами
              Даже если ввести другой тип данных,он превратится в строку.
                Пример: const obj = {
            ключ    //  name:    "Jonh", //   значение
                    age: 25,
                    isMarried: false
                    };
                Один обьект никогда не равен другому,даже если у них одинаковое содержимое.  
            Специальные обьекты:
                1. Массивы[] не является отдельным типом данных.Это частный случай обьекта,где ключи уже заданые по умолчанию(это нумерация).Служат для того,чтобы элементы располагались строго по порядку.Элементы массива начинают нумерацию с 0
                arr переменная,сокращенная от массива.
                2. Функции function
                3. Обьект Даты
                4. Регулярные выражения
                5. Ошибки

ОБЩЕНИЕ С ПОЛЬЗОВАТЕЛЕМ:
    alert(); модальное окно с кнопкой ОК.
    confirm();  модальное окно с с текстом вопроса question и двумя кнопками: OK и Отмена.
    prompt("" "всегда пустое"); модальное окно с текстом, полем для ввода текста и кнопками OK/Отмена.

ОПЕРАТОРЫ:
    1.Вычитание,сложение,деление,умножение.
    2.Оператор Инкримента ++ увеличение на единицу.
    3.Оператор Декримента -- уменьшение значения на единицу.
    4.Если ++ ставим перед значением называется ПРЕФИКСНОЙ.(сначала увеличение,а потом сравнение и выполнение.)
    5.Если после значения называется ПОСТФИКСНОЙ.(сначала возвращает старое значение,а после уже его увеличивает/уменьшает) Сначала сравнение,а потом увеличение.
    6. = это оператор присваивания. Если == это оператор сравнения. Если === строгое сравнение по типу данных.
    7. % возвращает оставшую часть после деления. 
        5%2 результат 1.
        11 % 3 = 2 (поскольку число 3 вмещается три раза, остатком будет число 2).
    8.Логические операторы:
            Оператор И это &&,работает тогда,когда два или больше подопытных явлюятся правдивыми выражениями.Всегда возвращает первое ложное значение,если оно есть и дальше код не идет.Если все верно,возвращается значение последнего аргумента.

            Оператор ИЛИ это ||,работает когда один из вариантов будет правдивым.Всегда возвращает первое правдивое значение,если оно есть и дальше код не идет.Если все неправда,возвращает последнее ложное значение.

            Результат логических операций это какое-то булиновое значение.
    9.Оператор ! :
            Оператор отрицания.
            Обращает значение в обратное;
            Сначала Превращает в булиновое и меняет на противоположное.
    10.Тернарный оператор ? :
            В его работе учавствует 3 аргумента:
            let result = условие ? значение1 : значение2;
    11. Оператор нулевого слияния (Nullish or ??) :
            Похож на оператор ||.
            Реагирует не на все 5 False которые существуют,а только на Null или undefined.
            Возвращает второй операнд,при сравнении,только если первый равен null/undefined.
    12. Оператор опциональной цепочки (?.):
            console.log(block?.textContent);
            Работает только на чтение,на запись будет ошибка.
            Проверяет выражение слева от себя и останавливает операции,если оно имеет значение null или undefined.
            Возвращает undefined.
                                            


УСЛОВИЯ:
            let test = 0;
                if ( test == true) {
                    console.log('Done');
                    } else {
                        console.log('Error');
                    } 
    Превращает любой тип данных в булиновый
    Конструкция switch всегда идет на строгое сравнение;


ЦИКЛЫ:

    let num = 50;
        1.Проверяет условие перед каждой итерацией.
        while (num < 55) {
            console.log(num);
            num++;
        }

        2. Проверяет условие после каждой итерации.
            do {
                console.log(num);
                num++;
            }
            while (num < 55);

        3.Проверяет условие перед каждой итерацией, есть возможность задать дополнительные настройки.
            for (let i = 1; i < 8; i++) {
                console.log(num);
                num++;
            }

            for (let i = 1; i < 10; i++) {
                if ( i === 6) {
                    break;             //  после заданного значения(6),цикл прерывается
                    continue;          //  позволяет пропустить тот шаг,который не нужен,но цикл идет.
                }
            }
            <script =>
ЦИКЛ В ЦИКЛЕ:
    for (let i = 0; i < 3; i++) {
        console.log(i);
        for (let j = 0; j   3; j++) {
            console.log(j);
        }
    }



ФУНКЦИИ:
    функции-это обьект,в который можно записать какие-то методы и св-ва
    Функции, начинающиеся с…
        "show…" обычно что-то показывают,
        "get…" – возвращают значение,
        "calc…" – что-то вычисляют,
        "create…" – что-то создают,
        "check…" – что-то проверяют и возвращают логическое значение, и т.д.

function showFirstMessage(text) {
    console.log(text);
}
showFirstMessage('Hello world');
Обязательно надо обращатся к имени функции showFirstMessage(),чтобы работало все.
Замыкание - это  функция которая запоминает свои внешние переменные и может получить к ним доступ.
    Все функции в джс являются замыканиями.
    Кроме конструкторов
return возвращает значение ф-кции либо окончание ф-кции.
Если результат работы ф-кции нужен для дальнейшей работы,используем слово return.

Классификация функций:
(1) function declaration - function showFirstMessage(text) {} 
Cуществует до того,как создана,как var. Точку с запятой в конце не ставить.

(2) function expression - const logger = function() {};
 Создается,только когда до нее доходит поток кода.
 
(3) Стрелочная функция - const calc = (a, b) => {return a + b };
Не имеет контекста вызова.Чаще всего можно встретить в обработчиках событий.

Параметр – это переменная, указанная в круглых скобках в объявлении функции.
    function calc(a, b) - параметр
Аргумент – это значение, которое передаётся функции при её вызове.
    calc(4, 6) - аргумент.


ФУНКЦИИ-КОНСТРУКТОРЫ:
Используются,когда нужна шаблонизация,чтобы создать множество однотипных обьектов.
    function User(name,id){         // функция конструктор
        this.name = name;
        this.id = id;
        this.human = true;
        this.hello = function() {               // внутри этой функции можно создавать методы.
            console.log(`Hello ${this.name}`);
        }
    }

    const ivan = new User('Ivan', 28);  // внутри этой переменной,находится не функция,а обьект.
    const alex = new User('Alex', 20);
        Функция User это конструктор,
        когда она вызывается при помощи ключевого слова new,
        она создает новый обьект,
        с теми свойствами,которые в нее записаны
        В этих функциях не нужен return

МЕТОДЫ И СВОЙСТВА:
    Методы это вспомогательные функции.
        МЕТОДЫ СТРОК:
            .toUpperCase()  преобразование строки в верхний регистр.
            .toLowerCase()  преобразование строки в нижний регистр.
            .replace('какой символ берем','на какой символ меняем'); меняет первый символ который найдет.
            .replace(/какой символ берем/g,'на какой символ меняем'); меняет все символы которые найдет.
            .indexOf(что ищем, [откуда начинать поиск]); осуществляет поиск подстроки
                Вернет позицию первого совпадения, а если оно не найдено, то вернет -1.
            .substr(откуда отрезать, [сколько символов отрезать]) указывает,сколько символов необходимо вырезать.
            .substring(откуда начать отрезать, [докуда отрезать])
                Например, написать str.substring(3, 0) все равно что написать str.substring(0, 3).
                Если какой-то из параметров больше, чем длина строки - он считается равным длине строки.
                Отрицательные значения приравниваются к нулю.
                Если не указать 2 аргумент,строка вырежится с заданой точки и до конца.
            .slice(откуда отрезать, [докуда отрезать]) Могут быть отриц.значения(отсчет с право налево).
                В методах substring и slice второй параметр должен быть на 1 больше того символа, который мы хотим забрать.
            .trim() убирает пробелы с начала и конца строки.
            .join(разделитель, массив)  превращает массив в строку с указанным разделителем.
                Разделитель задается параметром метода и не является обязательным. 
                Если он не задан - по умолчанию в качестве разделителя возьмется запятая. 
                Если вы хотите слить элементы массива без разделителя - укажите его как пустую строку ''.
            split([разделитель], [максимальное количество элементов]) превращает строку в массив по указанному разделителю.
                Разделитель указывается первым необязательным параметром. Если он не задан - вернется вся строка. Если он задан как пустые кавычки '' - то каждый символ строки попадет в отдельный элемент массива.
                 Вторым необязательным параметром можно указать максимальное количество элементов в получившемся массиве.
        МЕТОДЫ ЧИСЕЛ:
            Math всегда с большой буквы.
                Math.round(число) округление до ближайшего целого числа. 
                Math.abs(число) из отрицательного числа делает положительное. 
                Math.ceil(число) округление числа до целого всегда в большую сторону. 
                Math.floor(число) округление числа до целых всегда в меньшую сторону. 
                Math.min() возвращает минимальное число из группы чисел, переданных параметрами.
                    Если параметрами ничего не передано, то будет возращено Infinity.
                    Метод не работает с массивами,однако можно найти минимальное значение массива: 
                        Math.min.apply(null, arr), где arr - произвольный массив.
                Math.max() возвращает максимальное число из группы чисел, переданных в функцию.
                    Если в функцию ничего не передано, то будет возращено -Infinity.
                    Метод не работает с массивами,однако можно найти максимальное значение массива: 
                        Math.max.apply(null, arr), где arr - произвольный массив.
                Math.sqrt() возвращает квадратный корень числа.
                Math.pow(число, степень) возводит число в заданную степень.
                    Первым параметром передается число, вторым - в какую степень его возвести.
                Math.random() возвращает случайное дробное число от 0 до 1. 
                    Вывести случайное целое число от 1 до 100:
                        function getRandomInt(min, max) {
                            return Math.floor(Math.random() * (max - min + 1)) + min;
                        }
                        console.log(getRandomInt(1, 100));
                    Вывести случайное дробное число:
                        function getRandomArbitary(min, max) {
                            return Math.random() * (max - min) + min;
                        }
                toFixed() производит округление числа до указанного знака в дробной части.
                        let num = 1.1111;
                        console.log(num.toFixed(3));
                    Количество знаков указывается параметром.
                    Если число знаков не указано, то по умолчанию берется 0 знаков, то есть округление до целого числа.
                toPrecision(длина); 
                    Округляет число до заданного знака. 
                    В отличие от Math.round округление можно проводить не только в дробной части.
                    Параметром метода указывается сколько цифр должно остаться в числе.
                    Если указанное количество знаков не достижимо обрезанием десятичной части - переводит число в экспоненциальную форму.
                    Экспоненциальная форма - это числа вида 1.2e+3. Чтобы преобразовать в нормальную форму нужно сделать так: 1.2e+3 = 1.2 * 10*3 = 1.2 * 1000 = 1200.
                parseInt() переводит число в другую систему исчисления.
                parseFloat() возвращает число в десятичном измерении.
                isInteger() определяет, является ли переданное значение целым числом.
                    !Number.isInteger проверка на дробное число.
СВОЙСТВА:
    Это вспомогательные значения.Их никак не вызываем,пишем через точку.
    arr.length-свойство для получения длины строки либо других типов данных; 
    Состоит из последнего индекса который есть в массиве + 1.




МЕТОДЫ МАССИВОВ:
      .shift() удаляет первый элемент массива.
      .pop() удаляет последний элемент из массива. arr.pop()
      .push() неограниченное количество элементов в конец массива. arr.push(элемент, элемент, элемент...)
      .forEach() гибко перебрать элементы массива.
            arr.forEach(function(item,i,arr) {
                console.log(`${i}: ${item} внутри массива ${arr}`);
            });
        .sort() сортирует элементы как строки. 
            В алфавитном порядке. 
            С числами работает как посимвольное сравнение.
            Как сортировать числа от большего к меньшему:
                    const arr = [ 2, 13, 26, 8, 10];
                    arr.sort(compareNum);
                    console.log(arr);
                        function compareNum(a,b) {
                            return a - b;
                        }
        .reverse() изменяет порядок элементов в массиве на обратный. arr.reverse();
        .splice()  удаляет или добавляет элементы в массив. 
            массив.splice(откуда удаляем, сколько элементов удаляем, [вставить элемент], [вставить элемент]...);
            Первым параметром метод принимает номер элемента массива, который нужно удалить.
             Вторым параметром - сколько элементов массива следует удалить. 
             Если его поставить в 0 - то элементы удалены не будут (только добавлены новые).
            Дальше через запятую идут элементы, которые нужно добавить в массив (являются необязательными параметрами). Эти элементы добавятся вместо удаленных элементов массива.
        .concat() сливает указанные массивы в один общий массив. arr.concat(еще массив, и еще массив, и еще...).
        
       Array.isArray(obj) возвращает true,если обьект является массивом и false,если нет.
            Проверяет,является ли элемент обьектом.
        Array.find() возвращает значение первого найденного в массиве элемента.


ПЕРЕБОР МАССИВА:
    for (let value of arr) {
        console.log(value);
        }       


МЕТОДЫ ОБЬЕКТОВ:
    Object.keys(объект); возвращает массив СВОЙСТВ из собственных перечисляемых(те свойства,которые могут быть перечислены в цикле,и у которых enumerable true) свойств обьекта.
        Получает ключи объекта в виде массива. 
    Object.keys(объект).lenght кол-во элементов в обьекте.
    Object.values() возвращает массив ЗНАЧЕНИЙ перечислямых свойств обьекта в том же порядке,что и цикл for in.
        Получает значения обьекта в виде массива.
    Object.entries() возвращает массив пары [свойство,значение / key,value].
        Получение пары ключ,значение.
        Происходит создание двумерного массива (матрица) [[],[]].
    Object.assign(обьект в который будем помещать, обьект который помещаем) обьединение обьектов.
    Object.assign({}, обьект который помещаем) создаем поверхностную копию помещаемого обьекта.
    Object.is() позволяет сравнивать содержимое обьектов.
        Проверяет,являются ли два значения одинаковыми.

МЕТОДЫ ОБЬЕКТОВ ДЛЯ РАБОТЫ С ФЛАГАМИ,используются редко,знать надо:
    Object.preventExtensions() предотвращает любое расширение обьекта.
    Object.isExtensible() определяет,разрешено расширение обьекта или нет.
    Object.seal() запечатывает обьект,предотвращая добавление новых свойств. 
        Устанавливает у всех свойств configurable false
        writable остается true и существующие свойства можно изменять.
    Object.isSealed() определяет,является ли обьект запечатанным.
    Object.freeze() замораживает обьект
        Запрещает добавлять,изменять или удалять свойства.
        Обьект становится эффективно неизменным.
    Object.isFrozen() определяет,был ли заморожен обьект.
    

    Кроме строк,свойствами обьектов могут быть символы.


ПЕРЕБОР ОБЬЕКТА:
    Цикл для перебора свойств обьекта:
        let obj = {Коля: 200, Вася: 300, Петя: 400};
            for (key in obj) {
                console.log(obj[key]); 
            }

         const options = {
            name: 'test',
            width: 1024,
            height: 1024,
            colors: {
                border: 'black',
                bg: 'red'
            }
        };
            for (let key in options) {
                console.log(`Свойство ${key} имеет значение ${options[key]}`);
            }
            console.log(Object.keys(имя переменной).length);  // получение количества элементов внутри обьекта.

            const {border, bg} = options.colors; // Деструктуризация обьекта.
                console.log(border);



ДЕСТРУКТУРИЗАЦИЯ ОБЬЕКТА:
   const options = {
    name: 'test',
    width: '1024',
    height: '1024',
    colors: {
        border: 'black',
        bg: 'red'
    },
   };                       //обьект.

    const {border, bg} = options.colors; // деструктуризация обьекта выше.


SPREAD-оператор:
   Разворачивает структуру на отдельные значения.
   Оператор spread() разворачивает структуру и превращает ее в набор данных.
        const video = ['youtube', 'vimeo', 'rutube'],
        blogs = ['wordpress', 'livejournal', 'blogger'],
        internet = [...video, ...blogs, 'vk', 'fb'];
        console.log(internet);

        const array = ['a', 'b'];
        const newAarray = [...array];

REST-оператор :
   Противоположный spread оператору
   Отдельные элементы обьединяет в один массив
        const log = function(a, b, ...rest) { // rest оператор пишется как ... и всегда последним
            console.log(a, b, rest); // basic, advanc [массив]
        }
        log('basic', 'advanc', 'operator', 'usage');
    


ПРОТОТИПЫ:
  Наследует свойства указанного обьекта;
    Object.create(название обьекта св-ва которого будут наследоваться);
    Object.setPrototypeOf(обьект который будет наследовать,  обьект cв-ва которого будут наследоваться);



РАБОТА СО СТРАНИЦЕЙ:

   ПОЛУЧЕНИЕ ЭЛЕМЕНТОВ СО СТРАНИЦЫ:
   
        document.getElementById('передаем через строку id элемента'); 
                    получение элемента через id.
        document.getElementsByTagName('передаем через строку тег элемента'); 
                    получение коллекции элементов через тег в псевдомассив.
        document.getElementsByTagName('передаем через строку тег элемента')[номер элемента который хотим получить]; 
                    получаем конкретный элемент из псевдомассива.
        document.getElementsByTagName('передаем через строку тег элемента');
                console.log(имя переменной[номер элемента который хотим получить]); 
                    аналог пред команды.
        document.getElementsByClassName('передаем через строку класс элемента');
        document.querySelectorAll('.любой CSS-селектор'); 
                    Точка обязательна в скобках. 
                    Тут работает метод forEach.
                    Но это все равно псевдомассив.
        document.querySelector('любой элемент');
                    Позволяет получить первый элемент который попадает под описание параметра.
                    часто используют,когда есть только один один элемент на стр,чтобы с ним работали методы.
        document.body.children:
                    Получение всех элементов в body.   

                    nextElementSibling получает только соседний элемент,без получения текстовых узлов.

    РАБОТА С ЭЛЕМЕНТАМИ:
    
      data-атрибуты существуют для удобного ориентирования в элементах по их значению при помощи JS.
        document.createElement('название тега который создаем'); 
                Создание элемента.
                Сохраняет его только внутри джс файла,на стр не отображается.
        document.createTextNode('текст который создаем')
                Создание текста.
                Он появится на странице.
                Если четко хотим получить текст от пользователя и использовать его дальше.
        div.classList.add('класс,который хотим добавить');
        document.body.append(название элемента); \\ .appendChild(название элемента); Устаревшее. 
            Добавление элемента в конец.
            Добавляем элемент в самый конец body.
        document.querySelector('.элемент,в который хотим поместить новый элемент').append(div);
        элемент.prepend(название элемента);
            Добавление элемента в начало.
        псевдомассив[номер элемента].before(название элемента); \\ .insertBefore(название элемента,перед каким элементом);
            Ставим элемент ПЕРЕД указанным псевдомассивом(или его элементом);
        псевдомассив[номер элемента].after(название элемента);
            Ставим элемент ПОСЛЕ указанного псевдомассива(или его элементом).
        псевдомассив[номер элемента].remove(); \\ элемент.removeChild(псевдомассив[номер]);
            удаление указанного элемента.
        псевдомассив[номер элемента].replaceWith(каким элементом заменить); \\элемент.replaceChild(псевдомассив[номер]);
            Замена элемента на указанный.

    РАБОТА С ТЕКСТОМ:

    div.innerHTML = '<h1>Hello World</h1>';
        Создание текста.
        Можно ввводить HTML-структуры.
    div.textContent = 'Hello';
        Только текст.
    div.insertAdjacentHTML('', 'тот HTML который хотим вставить');
        Спец.слова(первый аргумент):
            beforebegin - вставляет HTML структуру перед элементом.
            afterbegin - в начало элемента.
            beforeend - в конец элемента.
            afterend - после элемента.



СОБЫТИЯ:

Выполняются в порядке очереди.
Всегда необходим обработчик события.Это функция которая срабатывает,как только событие произошло.
   Можно вешать на window. или на document.
click = Нажатие кнопкой мыши на элемент.
dblclick = Двойное нажатие мыши на элемент.
contextmenu = Нажатие правой кнопкой мыши.
mouseenter = Наведение мыши на элемент. 
mouseleave = Мышь перемещается от элемента, к которому подключён обработчик.
mouseout = Мышь перемещается от элемента, к которому подключён обработчик,или от одного из его дочерних элементов.

event.type определение произошедшего события в обработчике.

Обьект события,это обьект,который содержит всю информацию о произошедшим событии.
Обьект события обязательно передается как аргумент в callback функцию (event)/(e).
Всплытие событий - когда обработчик события сначала срабатывает на самом вложенном элементе,затем на родителе и так выше.
Чтобы сразу на несколько элементов вешать обработчики событий,нужно перебрать псевдомассив и на каждый элемент внутри навесить обработчик. 
Перебор методом forEach.
   
    КАК ДЕЛАТЬ:
        Можно назначать несколько событий на одной действие.
            btn.addEventListener('название события click', callback функция () => {
                alert('Click');
            });

            btn.addEventListener('mouseenter',(e) => {
                console.log(e.target);          Получение конкретного элемента.
                e.target.remove(); Применение метода на элемент.
                //console.log('Hover');
            } {once:true}); // команда после обработчика,позволяет использовать событие только один раз.
    
    НЕ ИСПОЛЬЗУЕМЫЕ СПОСОБЫ:
            1 способ:        Не используется почти.
                Прописываем в HTML-документе: <button onclick="alert('Click')" id="btn">Click me</button>
            2 способ:       Также почти не используется.
                const btn = document.querySelector('button');
                    btn.onclick = function() {
                        alert('click');
                    };

ОТМЕНА СТАНДАРТНОГО ПОВЕДЕНИЯ БРАУЗЕРА Ч\З обработчик СОБЫТИЯ:

    const link = document.querySelector('a');
    link.addEventListener('click', (event) => {
        event.preventDefault();             отмена стандартного поведения.
        console.log(event.target);          назначение нового.
    });


ДЕЛЕГИРОВАНИЕ Событий :
    Вешаем событие на все элементы,даже на те,которые будут добавлены динамически.            
    wrapper.addEventListener('click', (event) => {              // вешаем обработчик события на родителя
        if (event.target && event.target.tagName == "BUTTON") {  // проверяем,чтобы обработчик срабатывал на потомков.
            console.log('Hello');
        }
    });


    СОБЫТИЯ НА МОБИЛЬНЫХ УСТРОЙСТВАХ:
  Когда назначается мобильное событие,рекомендуется всегда ставить обьект события (e) => , и e.preventDefault() чтобы отменять стандартное поведение браузера.
    touchstart: 
        событие возникает, если происходит касание к элементу.
    touchmove: 
        событие возникает, если палец при касании элемента начинает двигаться по нему.
    touchend:
        возникает,как только палец оторвался от элемента.
    touchenter:
        возникает,когда ведем пальцем по экрану и при этом наскакиваем на элемент,на котором это событие.
    touchleave:
        когда палец продолжаем скользить по экрану и при этом вышел за границы элемента,на котором событие.
    touchcancel:
        когда точка соприкосновения больше не регистрируется на поверхности.

СВОЙСТВА НА МОБИЛЬНЫХ УСТРОЙСТВАХ:
    touches:
        подает список всех пальцев,которые в данный момент взаимодействуют с экраном.
    targetTouches:
        список всех пальцев,которые в данный момент взимодействуют  с элементом на стр.
    changedTouches:
        список пальцев,которые учавствуют в текущем событии.


РЕКУРСИЯ:
    Функция вызывает сама себя.
    Упрощает функцию.
    База рекурсии - случай, который приводит сразу к завершению функции. Когда Функция станет 1.
    Шаг рекурсии - запуск вложенной функции,но уже с другим значением.
    Глубина рекурсии - общее кол-во вложенных вызовов,вместе с самым первым. 
        Число n ниже в примере. 
        Макс.глубина около 10к вызовов.
    Не существует промежуточной переменной.

            function pow(x,n) {
                    if (n === 1) { // база рекурсии
                        return x;
                    } else {
                        return x * pow(x, n - 1); // pow(x, n - 1) тут будет результат возведение числа х в степень.
                    }
            }
            console.log(pow(2,4));


    let students = {
        js: [{
            name: 'John',
            progress: 100
        },{
            name: 'Ivan',
            progress: 60
        }],

        html: {
            basic: [{
                name: 'Peter',
                progress: 20
            },{
                name: 'Ann',
                progress: 18
            }],

            pro: [{
                name: 'Sam',
                progress: 10
            }]
        }    
    };

            РЕШЕНИЕ ЧЕРЕЗ ЦИКЛ:


function getTotalProgressByIteration (data) {
    let total = 0;
    let students = 0;

    for (let course of Object.values(data)) {       // получаем значение обьекта
        if (Array.isArray(course)) {                // проверяем,если это массив,выполняем это
            students += course.length;              // считаем студентов

            for (let i = 0; i < course.length; i ++) {
                total += course[i].progress;                // считаем из каждого студента прогресс
            }
        } else {                                                    // если это обьект,выполняем это
            for ( let subCourse of Object.values(course)) {
                students += subCourse.length;

                for(let i = 0; i < subCourse.length; i++) {
                    total += subCourse[i].progress;
                }
            }
        }
    }


        return total/students; // средний прогресс по всем студентам,которые зарегистрированы на все курсы.
    }

console.log(getTotalProgressByIteration(students));

                        РЕШЕНИЕ ЧЕРЕЗ РЕКУРСИЮ:


function getTotalProgressByRecursion(data) {
    if (Array.isArray(data)) {                // проверяем,если это массив,выполняем это
        let total = 0;                         // обьявляем промежуточную переменную

        for (let i = 0; i < data.length; i ++) {    // складываем все прогрессы в одну переменную,которую обьявили
            total += data[i].progress;
        }

        return [total, data.length];  //чтобы вернуть два значения,используем массив,это прогресс и кол-во студентов
    } else {                           // сама рекурсия,когда попадаем на обьект и начинаем перебирать
        let total = [0,0];              // сразу формируем массив с нулями,чтобы записать значения и вернуть в работу

        for (let subData of Object.values(data)) {          // перебираем обьекта и получаем только его значения
            const subDataArr = getTotalProgressByRecursion(subData); // заново запускаем функцию(рекурсия) и она решает что делать,если попадает на массив или на обьект
            total[0] += subDataArr[0];  //  общее значение всего прогресса Общее кол-во студентов,которое увеличиваем
            total[1] += subDataArr[1];
        }

        return total;
    }
}
    const result = getTotalProgressByRecursion(students);
    console.log(result[0]/result[1]);






АТРИБУТЫ defer и async:
        <script defer src="js/script"></script>   // можно ставить в начале body либо в head.
    defer:
        Сообщает бразуеру,что он должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме,а затем запустить этот скрипт,когда он загрузится.
        Скрипты с defer никогда не блокируют стр.
        Скрипты загружаются последовательно.
        Скрипты всегда выполняются,когда DOM дерево уже готово.
        Всегда дожидаются полной готовности верстки и срабатывают до события DOMContentLoaded.

        <script async src="js/script"></script>
    async:
      Нужны для подключения сторонних скриптов(например,метрики и счетчики),которые не особо подвязаны под DOM-структуру.
        Стр не ждет асинхронных скриптов,содержимое обрабатывается и отображается.
        Событие DOMContentLoaded и асинхронные скрипты не ждут друг друга.
        Скрипты абсолютно независимы,не ждут загрузки других скриптов и другие не ждут их.
        
СОЗДАНИЕ СКРИПТА НА СТР С ПОМОЩЬЮ JS: // ДИНАМИЧЕСКИ ЗАГРУЖАЕМЫЕ СКРИПТЫ:
        По умолчанию ведут себя как async.
    const script = document.createElement('script');
        script.src = 'js/test.js';
        document.body.append(script);
            Чтобы отключить поведение async:
                script.async = false;


ТИП ДАННЫХ SYMBOL:
  let id = Symbol('id');
    Нужны для того,чтобы создавать уникальные идентификаторы. 
    Уникальны и не изменяемы,даже если у них одинаковое описание. 
    Применяются к свойствам обьектов. 
    Позволяют создавать скрытые при обычном доступе свойства,которые не показываются при переборе обьекта,для того,чтобы случайно не перезаписать какое-либо свойство.
    Метод для нахождение символа в обьекте:
        Object.getOwnPropertySymbols(obj) // возвращает массив.
    Глобальный реестр символов:
        [Symbol.for('id')]: 123
            console.log(obj[Symbol.for('id')]);
        Теперь описание символа не будет уникальным.


ФЛАГИ:
  Нельзя их увидеть в консоли,они скрыты.
  для всех создаваемых вручную свойств,они всегда стоят в позиции true
    writable:
        Если в позиции true,то свойство в обьекте можно изменить.
        Если в позиции false,то доступно только для чтения.
    enumerable:
        Если в позиции true,то свойство будет перечисляться в циклах.
        Если в позиции false,то циклы его будут игнорировать.
    configurable:
        Если в позиции true,то свойство можно удалить,а атрибуты изменить.
        Если в позиции false,то делать этого нельзя.
  Метод для выведения флага в консоли:
    console.log(Object.getOwnPropertyDescriptor(обьект, свойство флаги которого нужно посмотреть.));
  Метод изменения параметров:
    Object.defineProperty(обьект, 'св-во обьекта которое хотим изменить', {обьект с флагами которые хотим модифицировать})
        При помощи этого метода,можно создавать новые св-ва,если указать такое,которого нет в списке этого обьекта
        Это св-во будет создано с задаными параметрами,которые прописываем в третьем аргументе.
        Если не указывать значение флагов,они автоматически станут false
  Метод,который позволяет редактировать сразу несколько свойств:
    Object.definesProperties(обьект, {обьект со св-вами которые нужны изменить})  



ИТЕРИРУЕМЫЕ КОНСТРУКЦИИ:
  Перебираемый или итерируемый обьект это тот,который мы можем использовать в for...of
    for...in при использовании на обьекте,массиве или строке будет работать с каждой сущностью по порядку,которая является перечисляемой(enumerable true).
        Сразу получает ключ.
    for...of проходится по значениям перебираемого обьекта.
        Сразу получает значение.
        Для обьектов не подходит,если у него нет встроенного символа-итератора. Symbol(Symbol.iterator)
        Дословно iterator это метод,который возвращает обьект с методом next()
        Результат метода next()  всегда обьект
            К итерируемым обьектам относятся:
                массивы,строки,типизированные массивы,set,map и DOM коллекции.
                    Два преимущества:
                        Строгое соответствие порядка в периборе.
                        Исключение всех лишних свойств,которые могут быть унаследованы.
    Если хочется сделать обьктов перебираемым,то итератор приходится создавать вручную.

                const salaries = {
                john: 500,
                ivan: 1000,
                ann: 5000,
                sayHello: function() {
                    console.log('Hello');
                }
            };
                    // пишем функционал для перебора всех этих зарплат,т.е делаем обьект итерируемым.
                                                            // Ручной вызов метода next():
                salaries[Symbol.iterator] = function() {    // это метод,его можно запустить при помощи().
                    return {                                // const iterator = salaries[Symbol.iterator]();
                        current: this.john,                 // console.log(iterator.next());
                        last: this.ann,

                        next() {
                            if (this.current < this.last) {
                                this.current = this.current + 500;
                                return {done: false, value: this.current};
                            } else {
                                return {done: true, value: 123};
                            }
                                        
                        }
                    };
                };

                for (let res of salaries) {
                    console.log(res);
                }

СТРУКТУРА (*)Map:
    Специфическая структура данных,которая оч похожа на обьект,только у них вместо свойств может использоваться все,что угодно.
    Порядок свойств в Map такой,в каком их добавляют.
    При создании новой Map внутри будет пусто,в том числе наследуемых свойств через прототип.
    Специфическая структура данных,т.к. у них есть свои методы для работы.
    По типу данных это все равно обьект.
    Если разбирать Map изнутри,то внутри это массив массивов.(технические особенности)

    const shops = [
    {rice: 500},
    {oil: 200},
    {bread: 50}
    ];

    const budget = [ 5000, 15000, 25000];

    const map = new Map([
        [{paper: 400}, 8000]        // примерно в таком виде в Map существуют данные.
    ]);



    МЕТОДЫ Map:
        map.set(ключ, значение);
                Преобразует ключ обьекта из строки в обьект.
        map.get(обьект);
            Получение значения по ключу обьекта,при работе с Map.
        map.has(обьект);
            Проверка на наличие чего-то внутри Map.
        map.delete(key);
                Удаляет элемент по ключу из Map.
        map.clear();
                Полностью очищает map 
                Становится пустым.


                shops.forEach((shop, i) => {
                map.set(shop, budget[i]); // соединяем две структуры
            });

            console.log(map.get(shops[0])); // получение значения
            console.log(map.has(shops[0])); // проверяем,существует ли обьект внутри Map


    Свойство map.size; 
        это кол-во элементов на данный момент внутри Map.

    МЕТОДЫ ПЕРЕБОРА map :
        map.keys()
            возвращает итерируемый обьект по ключам.
            const goods = [];
            for (let shop of map.keys()) {  // превращаем карту в массив с обьектами.
            goods.push(Object.keys(shop)[0]); // обращаемся к каждому обьекту,преобразуем их в массив,чтобы вытащить только свойства.
            }
            console.log(goods);
        map.values() 
            возвращает итерируемый объект по значениям.
                for (let price of map.values()) { 
                    console.log(price);
                }
        map.entries()
            возвращает итерируемый объект по парам вида [ключ, значение].
                for (let price of map.entries()) { // получаем ключ и  значение обьекта
                    console.log(price);
                }
        map.forEach((value, key, map) => {  // четвертый способ перебора через forEach
            console.log(key, value);
        });


    for ( let [shop,price] of map.entries()) {  // делим массив на две отдельные части.
        console.log(price, shop);
    }

    ПЕРЕВОД ОБЬЕКТА В ФОРМАТ Map:
    const userMap = new Map(Object.entries(obj));
    console.log(userMap);

    И ОБРАТНО:
    const newUserObj = Object.fromEntries(userMap);
    console.log(newUserObj);
                
СТРУКТУРА (*) WeakMap:
    Ключами могут быть только обьекты.
    Если нет ссылки на обьект и он существует только внутри WeakMap,то этот обьект будет удален из WeakMap/памяти.
    Доступны только методы: set(); get(); delete(); has();
    Не можем перебрать через for of
        let user = {name: 'Ivan'};
        let map = new WeakMap();
        map.set(user, 'data');
        user = null;            // обьект был удален и существует только в WeakMap
        console.log(map.has(user)); // получаем false




СТРУКТУРА (*)Set:
    Особый вид коллекции,по типу массива,где каждое значение встречается только один раз.
        const arr = [1, 1, 2, 2, 4, 5, 6, 5];

        const set = new Set(arr);
        console.log(set);

        МЕТОДЫ Set:
           set.add('Ivan') 
                в аргументе данные,которые приходят в Set;
            set.delete(value);
                удаление какого-либо значения.
            set.has(value);
                проверка наличие какого-либо значения.
            set.clear();
                полная очистка набора(массива)
            Свойство set.size размер набора.

            МЕТОДЫ ПЕРЕБОРА Set:
                for (let value of set) 
                    console.log(value);  
                    
                set.forEach((value, valueAgaing, set) => {   // т.к. ключей нет,второй аргумент это тот же value.
                    console.log(value, valueAgaing); 
                });   

                set.values();
                set.keys(); // этот метод присутствует для обратной совместимости с Map.
                set.entries(); // этот метод присутствует для обратной совместимости с Map.

        РЕАЛИЗАЦИЯ ФУНКЦИИ-ПОМОЩНИКА ДЛЯ ОТФИЛЬТРОВКИ МАССИВОВ:
                Происходит быстрая фильтрация,избавление массива от всех дублирующих значений.
                function unique(arr) {
                    return Array.from(new Set(arr)); // Создаем массив из набора данных Set
                }


СТРУКТУРА (*)Weakset:
    Аналогична обычному Set,но в WeakSet можно добавлять только обьекты.
    Если нет ссылки на обьект и он существует только внутри WeakSet,то этот обьект будет удален из WeakSet/памяти.
    Доступны только методы: add(); delete(); has();
    не является перебираемой структурой.

ТИП ДАННЫХ BigInt:
    console.log(Number.MAX_SAFE_INTEGER) максимальное допустимое число с которым работает JS. это 2^53-1
    Если нужно работать с большим числом,то используется тип данных BigInt
    Используется только когда это действительно нужно.

        const bigInt = 123123123123143534584371n; // для создания BigInt нужно в конце числа добавить знак n.
        const sameBigInt = BigInt(123123123123143534584371) // второй вариант создания.

        Особенности:
        BigInt нельзя использовать со встроенным обьектом Math.round и проч.
        Нельзя смешивать в операциях BigInt и обычные числа.
        С BigInt можно использовать +,  -,  /,  *,  **,  и %
        Деление всегда будет возвращать округленное число без дробной части.
                console.log(2n == 2); // будет true,только при нестрогом сравнении.
        Чтобы сложить BigInt и обычные числа необходима конвертация:
                let bigint = 1n;
                let number = 2;
                    console.log(bigint + BigInt(number)); // конвертация number в BigInt
                    console.log(Number(bigint) + number); // конвертация BigInt в number



classList И ДЕЛЕГИРОВАНИЕ СОБЫТИЙ:
    Методы classList:
                .classList.item() позволяет получить класс,который располагается под определенным индексом.
                .classList.add() позволяет добавить опредленные классы. через запятую,можно добавлять несколько классов
                .classList.remove() позвляет удалить ненужные классы. через запятую можно удалять несколько классов.
                .classList.toggle() позволяет тоглить классы.
                    Если класс сейчас есть на элементе,то класс будет убран
                    Если класса сейчас нет на элементе,то класс будет добавлен.
                .classList.contains() позволяет проверять наличие определенного класса на элементе.
                     Возвращает булиновое значение.

                

    СИНТАКСИС ДЛЯ ЗАПУСКА ЛЮБОЙ ОПЕРАЦИИ С ТЕЧЕНИЕМ ВРЕМЕНИ:
       const btn = document.querySelector('.btn');
       let timerId;
       let i = 0;


        btn.addEventListener('click', () => {
            timerId = setTimeout(logger,2000); // метод для запуска операции отложенно.
            timerId = setInterval(logger,2000); // метод для запуска функции интервалами
        });
        
        function logger () {
            if ( i === 3) {
                clearInterval(timerId) // обнуляет таймер задержки,и функция не выполняется
            }
            console.log('text');
            i++;
        }
    Рекурсивный вызов setTimeout() :
        Код всегда будет ждать строго отведенное ему время
        setTimeout ждет пока функция выполнится,потом ждет заданое время и потом только выполняется.

        let id = setTimeout(function log(){
            console.log('Hello');
            id = setTimeout(log,500);
        },500);



РАБОТА С ДАТАМИ:
Можно использовать для измерения как-либо промежутков времени
    Любую дату можно трансформироать в мс,и наоборот.
    Чтобы получить дату старше 1970 года,используем отрицательные значения. const now = new Date(-99999999);
       const now = new Date();  // создаем новую дату и помещаем ее в переменную now 
       console.log(now); // получаем текущую дату 2022-09-09T10:29:00.022Z
    МЕТОДЫ ДАТЫ get():
    Возвращают значение в соответствии с местным часовым поясом
    Используются для установки даты.
        console.log(now.getFullYear()); // выводит текущий год 
        console.log(now.getMonth()); // получаем текущий месяц. Месяцы считаются с 0
        console.log(now.getDate()); // получаем текущее число месяца.
        console.log(now.getDay()); // получаем номер дня недели Нумерация начинается с вс(0 день), сб это 6 день
        console.log(now.getHours()); // получаем текущий час
        console.log(now.getMinutes()); // получаем текущие минуты
        console.log(now.getSeconds()); // получаем текущие секунды
        console.log(now.getMiliSeconds()); // получаем текущие милисекунды
    АНАЛОГИ МЕТОДОВ С UTC(часовой пояс + 0):
        console.log(now.getUTCHours()) // синтаксис
    ДРУГИЕ МЕТОДЫ:
        console.log(now.getTimezoneOffset()); // метод для получения разницы в мин между часовым поясом и UTC
        console.log(now.getTime()); // возвращает кол-во мс прошедших с 1 января 1970 года
    МЕТОДЫ ДАТЫ set():
        Те же методы,только с приставкой set
        Используются для установки даты.
    Операция бенчмарк,смотрим на производительность системы:
                let start = new Date();
                    for (let i = 0; i < 100000; i++){
                        let some = i**3;
                    }
                let end = new Date();
                console.log(`Прошло ${end - start} милисекунд`);    // вычисляем сколько времени отработал цикл

Date.parse() метод для трансформации строки в дату.



ПАРАМЕТРЫ ДОКУМЕНТА И РАБОТА С НИМИ:
    clientWidth,clientTop,clientHeight
        методы для перемещения элемента,без учета margin и border и полосы прокрутки;
    offsetWidth,offsetTop,offsetHeight 
        методы для перемещения элемента,с учетом margin и border и полосы прокрутки;
    scrollHeight 
        получаем полную высоту элемента,с учетом прокрутки
    scrollTop
        получаем сколько пикселей пролистал прокруткой пользователь
    getBoundingClientRect()
        позволяет узнать полные координаты элемента
    window.getComputedStyle(элемент который интересует)
        позволяет узнать,какие стили CSS были применины к элементу.
        с помощью него можем получить стили псевдоэлементов,нужно указать второй аргумент для этого
        Не путать с inline стилями,которые появляются внутри верстки и прописываются прямо в тег

document.documentElement. можно использовать для модификации документа либо для получения свойств.
    scrollBy(ширина(х), высота(y))
    scrollTo(ширина(х), высота(y))
        Два метода,позволяют перемещаться по стр,первый относительно текущей позиции пользователя,второй относит. стр.


КОНТЕКТ ВЫЗОВА. THIS:
То,что окружает функцию и в каких условиях она вызывается.
У стрелочной функции нет своего контекста вызова,она всегда его будет брать у своего родителя
В обработчиках событиях,если используется стрелочная функция,то контекст вызова будет выдавать undefined
Когда вешаем обработчик событий с классической функцией,то контекст вызова будет сам элемент на котором произошло событие

    Функция может вызываться 4 способами:

    // 1)Вызов функции: Обычная функция: this = window, но если стоит use strict = undefined
            // Даже если используется функция внутри функции,контекст ее не меняется this = window/undefined

        function showThis() {
            console.log(this); // будет ссылаться на глобальный обьект window,если не включен use strict
        }
            showThis();

    // 2)Вызов метода: Если используем метод внутри обьекта,то контекст вызова всегда будет ссылаться на этот обьект
            // Если будет простой вызов функции внутри метода обьекта,то получим undefined

        const obj = {
            a: 20,
            b: 15,
            sum: function() {
                console.log(this);  // тут получаем обьект
                ShowLog() {
                    console.log(this); // тут получаем undefined 
                }
            }
        };
        obj.sum();

    // 3)Вызов конструктора: Внутри функции-конструктора контекст вызова для всех методов и свойств,будет только что созданный обьект
          // this в конструкторах и классах - это новый экземпляр обьекта.

        function User(name,id){         // функция конструктор
            this.name = name;
            this.id = id;
            this.human = true;
            this.hello = function() {               // внутри этой функции можно создавать методы.
                console.log(`Hello ${this.name}`); // метод ссылается на созданный обьект ниже
            }
        }
            const ivan = new User('Ivan', 28);  // только что соданный обьект

    // 4)Непрямой вызов:  Ручное присвоение this любой функции
        
        function sayName() {
            console.log(this):
            console.log(this.name);
        }
            const user = {
                name: 'John'
            };


    ВАРИАНТЫ РУЧНОГО ПРИСВОЕНИЯ КОНТЕКСТА:
        sayName.call(user, '',); // аргументы передаются через строку и запятую
        sayName.apply(user, []); // аргументы передаются через массив
    ВАРИАНТ СОЗДАНИЯ НОВОЙ ФУНКЦИИ СВЯЗАННУЮ С определенным КОНТЕКСТОМ:
        function count(num) {   // пишем функцию на удвоение числа
            return this*num;
        }
        const double = count.bind(2);   // новая функция у которой есть жестко привязанный контекст
        console.log(double(3)) // помещаем функцию и число которое хотим удвоить

        // контекст и стрелочная функция:
            const obj = {
                num: 5,
                sayNumber: function() { // метод ссылается на обьект,и выводится обьект,а не undefined
                    const say = () => {  // стрелочная функция ссылается на метод выше
                        console.log(this); // в норме undefined, но тут стрелочная фунция
                    };
                    say();
                }
            };


КЛАССЫ /(синтаксический сахар):
    Код внутри тела класса всегда выполняется в строгом режиме.
    Служат для создания новых обьектов
    Красивая обертка функции конструктора
            class Rectangle {       // название класса всегда пишется с большой буквы
                constructor (height, width) { // аргументы которые будем передавать в наследуемый обьект
                    this.height = height; // свойства
                    this.width = width;
                }

                calcArea() {            // создание метода класса
                    return this.height * this.width;
                }
            }

    class ColoredReactangleWithText extends Rectangle {  // этот класс будет наследоваться от класса Rectangle
        constructor(height, width, text, bgColor) {
    super(height, width); // вызывает свойства родителя, всегда должен идти первой строчкой после раскрытия констуктора
    this.text = text; // новые свойства
    this bgColor = bgColor;
        }
        showMyProps() {
            console.log(`Текст : ${this.text}, цвет: ${this.bgColor}`);     // новый метод
        }
    }

    const div = new ColoredReactangleWithText(25, 10, 'Hello World', 'red');
    div.showMyProps(); // метод который существует непосредственно в этом классе
    console.log(div.calcArea()); // метод который существует в его родителе
    
    const square = new Rectangle(10,10); // в переменной лежит обьект,с двумя свойствами и одним методом
    console.log(square.calcArea()); // получаем площадь

ПАРАМЕТРЫ ПО УМОЛЧАНИЮ:
    function calcOrDoube (number, basis = 2) { // через = задаем значение по умолчанию
        console.log(number * basis);
    }
    calcOrDouble(3);

JSON - Java Script Object Notation
    Маленький вес файла.
    Текстовый формат обмена данными, основанный на JavaScript. 
    Методы:
        JSON.stringify(обьект) превращает существующий обьект в формат JSON,все будет в двойных кавычках.
        JSON.parse(обьект)  превращает JSON обратно в обьект
    Глубокое клонирование обьекта:
        const clone = JSON.parse(JSON.stringify(обьект));




Принципы обьектно-ориентированного программирования:
  (1) Абстракция - отделяем концепцию / (шаблон) от ее экземпляра/созданные на основе концепции
  (2)  Наследование - способность обьекта или класса базироваться на другом обьекте или классе
Метод .matches('CSS селектор по которому будем что-то искать') 
    Определение селектора внутри того элемента,на котором он применяется.
Метод .closest('CSS селектор') 
    Определение селектора у родителей. 
    Находит первый элемент с таким селектором,который будет родителем.
    Возвращает null,если не находит заданный селектор.
String(num).split('');
    Разделяет число на цифры(104 будет 1 0 и 4);
!! превращают в булиновый тип данных.
window.  глобальная сущность,через которую мы видим  документ / (сайт).
У псевдомассивов не существует никаких методов,там только хранится информация по порядку.
+= модификация строки.
\n перенос строки в JS
"use strict"; 
    Директива для работы в современном(строгом) режиме,пишется в начале кода
    Строгий режим позволяет избавится от неточностей кода и недопускает их работу.
Команда typeof (); позволяет узнать,какой тип данных.
+ который ставится перед определенным аргументом называется УНАРНЫМ.
Java Script это высокоуровневый и интерпретируемый  язык программирования.
В ПРОГРАМИРОВАННИ НУМЕРАЦИЯ НАЧИНАЕТСЯ НЕ С 1,А С 0.
ВСЯ ИНФОРМАЦИЯ КОТОРАЯ ПРИХОДИТ ОТ ПОЛЬЗОВАТЕЛЯ,БУДЕТ В ВИДЕ СТРОК.
Важно отличать вызов функции от вызова метода. 
    Главным отличием является то, 
    Что для вызова метода необходим аксессор (<expression>.functionProperty() или <expression>['functionProperty']()), 
    а для вызова функции — нет (<expression>()).